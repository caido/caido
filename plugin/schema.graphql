directive @oneOf on INPUT_OBJECT

scalar Alias

type AliasTakenUserError implements UserError {
	alias: String!
	code: String!
}

enum Alteration {
	MANUAL
	NONE
	TAMPER
}

enum AssistantErrorReason {
	CONTEXT_EXCEEDED
	INVALID_MODEL
	OFFLINE
	QUOTA_EXCEEDED
	UNKNOWN
}

type AssistantMessage {
	content: String!
	id: ID!
	role: AssistantMessageRole!
	session: AssistantSession!
}

"""
An edge in a connection.
"""
type AssistantMessageEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: AssistantMessage!
}

enum AssistantMessageRole {
	ASSISTANT
	SYSTEM
	USER
}

type AssistantMessageTask {
	error: AssistantMessageTaskError
	id: ID!
	message: AssistantMessage
	session: AssistantSession!
}

union AssistantMessageTaskError = AssistantUserError | AuthenticationUserError | OtherUserError

type AssistantModel {
	id: ID!
	name: String!
	tokenCredit: Int!
}

type AssistantSession {
	createdAt: DateTime!
	id: ID!
	messages: [AssistantMessage!]!
	modelId: ID!
	name: String!
	updatedAt: DateTime!
}

"""
An edge in a connection.
"""
type AssistantSessionEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: AssistantSession!
}

type AssistantUsage {
	balance: Int!
}

type AssistantUserError implements UserError {
	code: String!
	reason: AssistantErrorReason!
}

enum AuthenticationErrorReason {
	CLOUD_ERROR
	CLOUD_UNAVAILABLE
	DENIED
	EXPIRED
	INTERNAL
	INVALID
	STALE_DATE
}

type AuthenticationRequest {
	expiresAt: DateTime!
	id: ID!
	userCode: String!
	verificationUrl: Url!
}

enum AuthenticationScope {
	ASSISTANT
	OFFLINE
	PROFILE_READ
}

type AuthenticationToken {
	accessToken: Token!
	expiresAt: DateTime!
	refreshToken: Token
	scopes: [AuthenticationScope!]!
}

type AuthenticationUserError implements UserError {
	code: String!
	reason: AuthenticationErrorReason!
}

type AutomateConcurrencySetting {
	delay: Int!
	workers: Int!
}

input AutomateConcurrencySettingInput {
	delay: Int!
	workers: Int!
}

type AutomateEntry {
	connection: ConnectionInfo!
	createdAt: Timestamp!
	id: ID!
	name: String!
	raw: Blob!
	requests(after: String, before: String, first: Int, last: Int, filter: HTTPQL, order: AutomateEntryRequestOrderInput): AutomateEntryRequestConnection!
	requestsByOffset(limit: Int, offset: Int, filter: HTTPQL, order: AutomateEntryRequestOrderInput): AutomateEntryRequestConnection!
	session: AutomateSession!
	settings: AutomateSettings!
}

"""
An edge in a connection.
"""
type AutomateEntryEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: AutomateEntry!
}

type AutomateEntryRequest {
	automateEntryId: ID!
	error: String
	payloads: [AutomateEntryRequestPayload!]!
	request: Request!
	sequenceId: ID!
}

type AutomateEntryRequestConnection {
	count: Count!
	"""
	A list of edges.
	"""
	edges: [AutomateEntryRequestEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [AutomateEntryRequest!]!
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	snapshot: Snapshot!
}

"""
An edge in a connection.
"""
type AutomateEntryRequestEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: AutomateEntryRequest!
}

enum AutomateEntryRequestOrderBy {
	ID
	PAYLOAD_0
	PAYLOAD_1
	PAYLOAD_2
	PAYLOAD_3
	PAYLOAD_4
	POSITION
	RESP_LENGTH
	RESP_ROUNDTRIP_TIME
	RESP_STATUS_CODE
}

input AutomateEntryRequestOrderInput {
	by: AutomateEntryRequestOrderBy!
	ordering: Ordering!
}

type AutomateEntryRequestPayload {
	position: Int
	raw: Blob
}

type AutomateHostedFilePayload {
	delimiter: String
	id: ID!
}

input AutomateHostedFilePayloadInput {
	delimiter: String
	id: ID!
}

type AutomateNullPayload {
	quantity: Int!
}

input AutomateNullPayloadInput {
	quantity: Int!
}

type AutomateNumberPayload {
	range: Range!
}

input AutomateNumberPayloadInput {
	range: RangeInput!
}

type AutomatePayload {
	options: AutomatePayloadOptions!
	preprocessors: [AutomatePreprocessor!]!
}

input AutomatePayloadInput {
	options: AutomatePayloadOptionsInput!
	preprocessors: [AutomatePreprocessorInput!]!
}

union AutomatePayloadOptions = AutomateSimpleListPayload | AutomateHostedFilePayload | AutomateNullPayload | AutomateNumberPayload

input AutomatePayloadOptionsInput @oneOf {
	hostedFile: AutomateHostedFilePayloadInput
	null: AutomateNullPayloadInput
	number: AutomateNumberPayloadInput
	simpleList: AutomateSimpleListPayloadInput
}

enum AutomatePayloadStrategy {
	ALL
	MATRIX
	PARALLEL
	SEQUENTIAL
}

type AutomatePlaceholder {
	end: Int!
	start: Int!
}

input AutomatePlaceholderInput {
	end: Int!
	start: Int!
}

type AutomatePrefixPreprocessor {
	value: String!
}

input AutomatePrefixPreprocessorInput {
	value: String!
}

type AutomatePreprocessor {
	options: AutomatePreprocessorOptions!
}

input AutomatePreprocessorInput {
	options: AutomatePreprocessorOptionsInput!
}

union AutomatePreprocessorOptions = AutomatePrefixPreprocessor | AutomateSuffixPreprocessor | AutomateUrlEncodePreprocessor | AutomateWorkflowPreprocessor

input AutomatePreprocessorOptionsInput @oneOf {
	prefix: AutomatePrefixPreprocessorInput
	suffix: AutomateSuffixPreprocessorInput
	urlEncode: AutomateUrlEncodePreprocessorInput
	workflow: AutomateWorkflowPreprocessorInput
}

type AutomateRetryOnFailureSetting {
	backoff: Int!
	maximumRetries: Int!
}

input AutomateRetryOnFailureSettingInput {
	backoff: Int!
	maximumRetries: Int!
}

type AutomateSession {
	connection: ConnectionInfo!
	createdAt: Timestamp!
	entries: [AutomateEntry!]!
	id: ID!
	name: String!
	raw: Blob!
	settings: AutomateSettings!
}

type AutomateSessionConnection {
	count: Count!
	"""
	A list of edges.
	"""
	edges: [AutomateSessionEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [AutomateSession!]!
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	snapshot: Snapshot!
}

"""
An edge in a connection.
"""
type AutomateSessionEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: AutomateSession!
}

type AutomateSettings {
	closeConnection: Boolean!
	concurrency: AutomateConcurrencySetting!
	payloads: [AutomatePayload!]!
	placeholders: [AutomatePlaceholder!]!
	retryOnFailure: AutomateRetryOnFailureSetting!
	strategy: AutomatePayloadStrategy!
	updateContentLength: Boolean!
}

input AutomateSettingsInput {
	closeConnection: Boolean!
	concurrency: AutomateConcurrencySettingInput!
	payloads: [AutomatePayloadInput!]!
	placeholders: [AutomatePlaceholderInput!]!
	retryOnFailure: AutomateRetryOnFailureSettingInput!
	strategy: AutomatePayloadStrategy!
	updateContentLength: Boolean!
}

type AutomateSimpleListPayload {
	list: [String!]!
}

input AutomateSimpleListPayloadInput {
	list: [String!]!
}

type AutomateSuffixPreprocessor {
	value: String!
}

input AutomateSuffixPreprocessorInput {
	value: String!
}

type AutomateTask {
	entry: AutomateEntry!
	id: ID!
	paused: Boolean!
}

type AutomateTaskConnection {
	count: Count!
	"""
	A list of edges.
	"""
	edges: [AutomateTaskEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [AutomateTask!]!
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	snapshot: Snapshot!
}

"""
An edge in a connection.
"""
type AutomateTaskEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: AutomateTask!
}

enum AutomateTaskErrorReason {
	INTERNAL
	INVALID_HOSTED_FILE
}

type AutomateTaskUserError implements UserError {
	code: String!
	reason: AutomateTaskErrorReason!
}

type AutomateUrlEncodePreprocessor {
	charset: String
	nonAscii: Boolean!
}

input AutomateUrlEncodePreprocessorInput {
	charset: String
	nonAscii: Boolean!
}

type AutomateWorkflowPreprocessor {
	id: ID!
}

input AutomateWorkflowPreprocessorInput {
	id: ID!
}

type Backup {
	createdAt: DateTime!
	downloadUri: Uri
	id: ID!
	name: String!
	path: String!
	project: Project
	size: Int!
	status: BackupStatus!
	updatedAt: DateTime!
}

enum BackupErrorReason {
	INVALID
	NOT_DONE
}

input BackupSource @oneOf {
	backupId: ID
	file: Upload
}

enum BackupStatus {
	DONE
	ERROR
	PROCESSING
}

type BackupTask {
	backup: Backup!
	id: ID!
}

union BackupTaskError = BackupUserError | InternalUserError | OtherUserError

type BackupUserError implements UserError {
	code: String!
	reason: BackupErrorReason!
}

scalar Blob


type Browser {
	id: ID!
	installedAt: DateTime!
	latest: Boolean!
	path: String!
	size: Int!
	version: String!
}

union CancelAutomateTaskError = UnknownIdUserError | OtherUserError

type CancelAutomateTaskPayload {
	cancelledId: ID
	userError: CancelAutomateTaskError
}

union CancelBackupTaskError = UnknownIdUserError | OtherUserError

type CancelBackupTaskPayload {
	cancelledId: ID
	error: CancelBackupTaskError
}

type CancelDataExportTaskPayload {
	cancelledId: ID
	userError: CancelExportTaskError
}

union CancelExportTaskError = UnknownIdUserError | OtherUserError

union CancelRestoreBackupTaskError = UnknownIdUserError | OtherUserError

type CancelRestoreBackupTaskPayload {
	cancelledId: ID
	error: CancelRestoreBackupTaskError
}

union CancelTaskError = UnknownIdUserError | OtherUserError

type CancelTaskPayload {
	cancelledId: ID
	error: CancelTaskError
}

type ConnectionInfo {
	host: String!
	isTls: Boolean!
	port: Port!
}

input ConnectionInfoInput {
	host: String!
	isTLS: Boolean!
	port: Port!
}

type Count {
	snapshot: Snapshot!
	value: Int!
}

union CreateAssistantSessionError = PermissionDeniedUserError | OtherUserError

input CreateAssistantSessionInput {
	modelId: ID!
	systemMessage: String
}

type CreateAssistantSessionPayload {
	error: CreateAssistantSessionError
	session: AssistantSession
}

input CreateAutomateSessionInput {
	requestSource: RequestSourceInput
}

type CreateAutomateSessionPayload {
	session: AutomateSession
}

union CreateBackupError = TaskInProgressUserError | PermissionDeniedUserError | OtherUserError

type CreateBackupPayload {
	error: CreateBackupError
	task: BackupTask
}

union CreateFilterPresetError = NameTakenUserError | AliasTakenUserError | PermissionDeniedUserError | OtherUserError

input CreateFilterPresetInput {
	alias: Alias!
	clause: HTTPQL!
	name: String!
}

type CreateFilterPresetPayload {
	error: CreateFilterPresetError
	filter: FilterPreset
}

union CreateFindingError = UnknownIdUserError | OtherUserError

input CreateFindingInput {
	dedupeKey: String
	description: String
	reporter: String!
	title: String!
}

type CreateFindingPayload {
	error: CreateFindingError
	finding: Finding
}

input CreateProjectInput {
	name: String!
}

type CreateProjectPayload {
	error: CreateProjectPayloadError
	project: Project
}

union CreateProjectPayloadError = NameTakenUserError | PermissionDeniedUserError | OtherUserError

input CreateReplaySessionCollectionInput {
	name: String!
}

type CreateReplaySessionCollectionPayload {
	collection: ReplaySessionCollection
}

input CreateReplaySessionInput {
	collectionId: ID
	requestSource: RequestSourceInput
}

type CreateReplaySessionPayload {
	session: ReplaySession
}

union CreateScopeError = InvalidGlobTermsUserError | OtherUserError

input CreateScopeInput {
	allowlist: [String!]!
	denylist: [String!]!
	name: String!
}

type CreateScopePayload {
	error: CreateScopeError
	scope: Scope
}

union CreateSitemapEntriesError = UnknownIdUserError | OtherUserError

type CreateSitemapEntriesPayload {
	error: CreateSitemapEntriesError
}

input CreateTamperRuleCollectionInput {
	name: String!
}

type CreateTamperRuleCollectionPayload {
	collection: TamperRuleCollection
}

union CreateTamperRuleError = InvalidRegexUserError | InvalidHTTPQLUserError | OtherUserError

input CreateTamperRuleInput {
	collectionId: ID!
	condition: HTTPQL
	isEnabled: Boolean!
	isRegex: Boolean!
	matchTerm: String!
	name: String!
	replaceTerm: String!
	strategy: TamperStrategy!
}

type CreateTamperRulePayload {
	error: CreateTamperRuleError
	rule: TamperRule
}

input CreateUpstreamProxyHttpInput {
	allowlist: [String!]!
	auth: UpstreamProxyAuthInput
	connection: ConnectionInfoInput!
	denylist: [String!]!
	enabled: Boolean!
}

type CreateUpstreamProxyHttpPayload {
	proxy: UpstreamProxyHttp
}

input CreateUpstreamProxySocksInput {
	allowlist: [String!]!
	auth: UpstreamProxyAuthInput
	connection: ConnectionInfoInput!
	denylist: [String!]!
	enabled: Boolean!
	includeDns: Boolean!
}

type CreateUpstreamProxySocksPayload {
	proxy: UpstreamProxySocks
}

union CreateWorkflowError = WorkflowUserError | OtherUserError

input CreateWorkflowInput {
	definition: JsonObject!
	global: Boolean!
}

type CreateWorkflowPayload {
	error: CreateWorkflowError
	workflow: Workflow
}

type CreatedAssistantMessagePayload {
	messageEdge: AssistantMessageEdge!
	snapshot: Snapshot!
}

type CreatedAssistantMessageTaskPayload {
	task: AssistantMessageTask!
}

type CreatedAssistantSessionPayload {
	sessionEdge: AssistantSessionEdge!
	snapshot: Snapshot!
}

union CreatedAuthenticationTokenError = AuthenticationUserError | OtherUserError

type CreatedAuthenticationTokenPayload {
	error: CreatedAuthenticationTokenError
	token: AuthenticationToken
}

type CreatedAutomateEntryPayload {
	automateEntryEdge: AutomateEntryEdge!
	snapshot: Snapshot!
}

type CreatedAutomateEntryRequestPayload {
	automateEntryRequestEdge(order: AutomateEntryRequestOrderInput): AutomateEntryRequestEdge!
	snapshot: Snapshot!
}

type CreatedAutomateSessionPayload {
	automateSessionEdge: AutomateSessionEdge!
	snapshot: Snapshot!
}

type CreatedAutomateTaskPayload {
	automateTaskEdge: AutomateTaskEdge!
	snapshot: Snapshot!
}

type CreatedBackupPayload {
	backup: Backup!
}

type CreatedDataExportPayload {
	dataExportEdge: DataExportEdge!
	snapshot: Snapshot!
}

type CreatedDataExportTaskPayload {
	exportTaskEdge: DataExportTaskEdge!
}

type CreatedFilterPresetPayload {
	filterEdge: FilterPresetEdge!
}

type CreatedFindingPayload {
	findingEdge(order: FindingOrderInput): FindingEdge!
	snapshot: Snapshot!
}

type CreatedInterceptEntryPayload {
	interceptEntryEdge(order: InterceptEntryOrderInput): InterceptEntryEdge!
	snapshot: Snapshot!
}

type CreatedInterceptMessagePayload {
	messageEdge: InterceptMessageEdge!
	snapshot: Snapshot!
}

type CreatedPluginEventPayload {
	eventArgs: [JsonRaw!]!
	eventName: String!
	pluginId: ID!
}

type CreatedPluginPackagePayload {
	package: PluginPackage!
}

type CreatedProjectPayload {
	project: Project!
}

type CreatedReplaySessionCollectionPayload {
	collectionEdge: ReplaySessionCollectionEdge!
	snapshot: Snapshot!
}

type CreatedReplaySessionPayload {
	sessionEdge: ReplaySessionEdge!
	snapshot: Snapshot!
}

type CreatedRequestPayload {
	requestEdge(order: RequestResponseOrderInput): RequestEdge!
	snapshot: Snapshot!
}

type CreatedScopePayload {
	scopeEdge: ScopeEdge!
	snapshot: Snapshot!
}

type CreatedSitemapEntryPayload {
	ancestorIds: [ID!]!
	requestEdge(order: RequestResponseOrderInput): RequestEdge
	sitemapEntryEdge: SitemapEntryEdge!
	snapshot: Snapshot!
}

type CreatedStreamPayload {
	snapshot: Snapshot!
	streamEdge(order: StreamOrderInput): StreamEdge!
}

type CreatedStreamWsMessagePayload {
	messageEdge(order: StreamWsMessageOrderInput): StreamWsMessageEdge!
	snapshot: Snapshot!
}

type CreatedTamperRuleCollectionPayload {
	collectionEdge: TamperRuleCollectionEdge!
	snapshot: Snapshot!
}

type CreatedTamperRulePayload {
	ruleEdge: TamperRuleEdge!
	snapshot: Snapshot!
}

type CreatedUpstreamProxyHttpPayload {
	proxy: UpstreamProxyHttp!
}

type CreatedUpstreamProxySocksPayload {
	proxy: UpstreamProxySocks!
}

type CreatedWorkflowPayload {
	workflowEdge: WorkflowEdge!
}

type DataExport {
	createdAt: DateTime!
	downloadUri: Uri
	error: String
	format: DataExportFormat!
	id: ID!
	name: String!
	path: String!
	size: Int!
	status: DataExportStatus!
}

"""
An edge in a connection.
"""
type DataExportEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: DataExport!
}

enum DataExportFormat {
	CSV
	JSON
}

input DataExportSettings {
	includeRaw: Boolean!
}

enum DataExportStatus {
	CANCELLED
	DONE
	ERROR
	PROCESSING
}

type DataExportTask {
	export: DataExport!
	id: ID!
}

"""
An edge in a connection.
"""
type DataExportTaskEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: DataExportTask!
}

"""
A datetime with timezone offset.

The input is a string in RFC3339 format, e.g. "2022-01-12T04:00:19.12345Z"
or "2022-01-12T04:00:19+03:00". The output is also a string in RFC3339
format, but it is always normalized to the UTC (Z) offset, e.g.
"2022-01-12T04:00:19.12345Z".
"""
scalar DateTime

type DeleteAssistantSessionPayload {
	deletedId: ID
}

type DeleteAutomateEntriesPayload {
	deletedIds: [ID!]!
	errors: [DeleteAutomateEntryError!]!
}

union DeleteAutomateEntryError = TaskInProgressUserError | OtherUserError

type DeleteAutomateSessionPayload {
	deletedId: ID
}

union DeleteBackupError = TaskInProgressUserError | OtherUserError

type DeleteBackupPayload {
	deletedId: ID
	error: DeleteBackupError
}

type DeleteBrowserPayload {
	deletedId: ID
}

union DeleteDataExportError = TaskInProgressUserError | OtherUserError

type DeleteDataExportPayload {
	deletedId: ID
	userError: DeleteDataExportError
}

type DeleteFilterPresetPayload {
	deletedId: ID
}

type DeleteFindingsPayload {
	deletedIds: [ID!]
}

type DeleteHostedFilePayload {
	deletedId: ID
}

union DeleteInterceptEntriesError = TaskInProgressUserError | OtherUserError

type DeleteInterceptEntriesPayload {
	task: DeleteInterceptEntriesTask
	userError: DeleteInterceptEntriesError
}

type DeleteInterceptEntriesTask {
	deletedEntryIds: [ID!]!
	id: ID!
}

union DeleteInterceptEntriesTaskError = InternalUserError | OtherUserError

union DeleteInterceptEntryError = UnknownIdUserError | OtherUserError

type DeleteInterceptEntryPayload {
	deletedId: ID
	userError: DeleteInterceptEntryError
}

type DeleteProjectPayload {
	deletedId: ID
	error: DeleteProjectPayloadError
}

union DeleteProjectPayloadError = ProjectUserError | UnknownIdUserError | OtherUserError

type DeleteReplaySessionCollectionPayload {
	deletedId: ID
}

type DeleteReplaySessionsPayload {
	deletedIds: [ID!]
}

type DeleteScopePayload {
	deletedId: ID!
}

type DeleteTamperRuleCollectionPayload {
	deletedId: ID
}

type DeleteTamperRulePayload {
	deletedId: ID
}

type DeleteUpstreamProxyHttpPayload {
	deletedId: ID
}

type DeleteUpstreamProxySocksPayload {
	deletedId: ID
}

union DeleteWorkflowError = UnknownIdUserError | ReadOnlyUserError | OtherUserError

type DeleteWorkflowPayload {
	deletedId: ID
	error: DeleteWorkflowError
}

type DeletedAssistantSessionPayload {
	deletedSessionId: ID!
	snapshot: Snapshot!
}

type DeletedAutomateEntryPayload {
	deletedAutomateEntryId: ID!
	snapshot: Snapshot!
}

type DeletedAutomateSessionPayload {
	deletedAutomateSessionId: ID!
	snapshot: Snapshot!
}

union DeletedAutomateTaskError = AutomateTaskUserError | OtherUserError

type DeletedAutomateTaskPayload {
	deletedAutomateTaskId: ID!
	error: DeletedAutomateTaskError
	snapshot: Snapshot!
}

type DeletedBackupPayload {
	deletedBackupId: ID!
}

type DeletedBrowserPayload {
	deletedBrowserId: ID!
}

type DeletedDataExportPayload {
	deletedDataExportId: ID!
	snapshot: Snapshot!
}

type DeletedDataExportTaskPayload {
	deletedExportTaskId: ID!
}

type DeletedFilterPresetPayload {
	deletedFilterId: ID!
}

type DeletedFindingsPayload {
	deletedFindingIds: [ID!]!
	snapshot: Snapshot!
}

type DeletedHostedFilePayload {
	deletedHostedFileId: ID!
}

type DeletedInterceptEntryPayload {
	deletedEntryId: ID!
	snapshot: Snapshot!
}

type DeletedInterceptMessagePayload {
	deletedMessageId: ID!
	snapshot: Snapshot!
}

type DeletedPluginPackagePayload {
	deletedPackageId: ID!
}

type DeletedProjectPayload {
	deletedProjectId: ID!
}

type DeletedReplaySessionCollectionPayload {
	deletedCollectionId: ID!
	snapshot: Snapshot!
}

type DeletedReplaySessionPayload {
	deletedSessionId: ID!
	snapshot: Snapshot!
}

type DeletedScopePayload {
	deletedScopeId: ID!
	snapshot: Snapshot!
}

type DeletedTamperRuleCollectionPayload {
	deletedCollectionId: ID!
	snapshot: Snapshot!
}

type DeletedTamperRulePayload {
	deletedRuleId: ID!
	snapshot: Snapshot!
}

type DeletedUpstreamProxyHttpPayload {
	deletedProxyId: ID!
}

type DeletedUpstreamProxySocksPayload {
	deletedProxyId: ID!
}

type DeletedWorkflowPayload {
	deletedWorkflowId: ID!
}

type DisableTamperRulePayload {
	rule: TamperRule
}

type DropInterceptMessagePayload {
	droppedId: ID
}

type DuplicateAutomateSessionPayload {
	session: AutomateSession
}

type EnableTamperRulePayload {
	rule: TamperRule
}

input FilterClauseFindingInput {
	reporter: String
}

type FilterPreset {
	alias: Alias!
	clause: HTTPQL!
	id: ID!
	name: String!
}

"""
An edge in a connection.
"""
type FilterPresetEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: FilterPreset!
}

type Finding {
	createdAt: Timestamp!
	dedupeKey: String
	description: String
	host: String!
	id: ID!
	path: String!
	reporter: String!
	request: Request!
	title: String!
}

type FindingConnection {
	count: Count!
	"""
	A list of edges.
	"""
	edges: [FindingEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Finding!]!
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	snapshot: Snapshot!
}

"""
An edge in a connection.
"""
type FindingEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: Finding!
}

enum FindingOrderBy {
	CREATED_AT
	HOST
	ID
	PATH
	REPORTER
	TITLE
}

input FindingOrderInput {
	by: FindingOrderBy!
	ordering: Ordering!
}

type FinishedBackupTaskCancelled {
	taskId: ID!
}

type FinishedBackupTaskError {
	error: BackupTaskError!
	taskId: ID!
}

union FinishedBackupTaskPayload = FinishedBackupTaskSuccess | FinishedBackupTaskError | FinishedBackupTaskCancelled

type FinishedBackupTaskSuccess {
	task: BackupTask!
}

type FinishedDeleteInterceptEntriesTaskPayload {
	error: DeleteInterceptEntriesTaskError
	task: DeleteInterceptEntriesTask!
}

type FinishedRestoreBackupTaskCancelled {
	taskId: ID!
}

type FinishedRestoreBackupTaskError {
	error: RestoreBackupTaskError!
	taskId: ID!
}

union FinishedRestoreBackupTaskPayload = FinishedRestoreBackupTaskSuccess | FinishedRestoreBackupTaskError | FinishedRestoreBackupTaskCancelled

type FinishedRestoreBackupTaskSuccess {
	task: RestoreBackupTask!
}

type FinishedTaskPayload {
	error: UserError
	task: Task!
}


input ForwardInterceptMessageInput @oneOf {
	request: ForwardInterceptRequestMessageInput
	response: ForwardInterceptResponseMessageInput
}

type ForwardInterceptMessagePayload {
	forwardedId: ID
}

input ForwardInterceptRequestMessageInput {
	updateContentLength: Boolean!
	updateRaw: Blob!
}

input ForwardInterceptResponseMessageInput {
	updateContentLength: Boolean!
	updateRaw: Blob!
}

type GlobalConfig {
	address: String!
	onboarding: OnboardingState!
}

union GlobalizeWorkflowError = UnknownIdUserError | ReadOnlyUserError | WorkflowUserError | OtherUserError

type GlobalizeWorkflowPayload {
	error: GlobalizeWorkflowError
	workflow: Workflow
}

scalar HTTPQL

type HostedFile {
	createdAt: DateTime!
	id: ID!
	name: String!
	path: String!
	size: Int!
	updatedAt: DateTime!
}


scalar Image

union InstallBrowserError = UnsupportedPlatformUserError | OtherUserError

type InstallBrowserPayload {
	browser: Browser
	error: InstallBrowserError
}

union InstallPluginPackageError = PluginUserError | StoreUserError | OtherUserError

input InstallPluginPackageInput {
	source: PluginPackageSource!
}

type InstallPluginPackagePayload {
	error: InstallPluginPackageError
	package: PluginPackage
}


type InterceptEntry {
	id: ID!
	request: Request!
}

type InterceptEntryConnection {
	count: Count!
	"""
	A list of edges.
	"""
	edges: [InterceptEntryEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [InterceptEntry!]!
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	snapshot: Snapshot!
}

"""
An edge in a connection.
"""
type InterceptEntryEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: InterceptEntry!
}

enum InterceptEntryOrderBy {
	ID
	REQ_CREATED_AT
	REQ_FILE_EXTENSION
	REQ_HOST
	REQ_METHOD
	REQ_PATH
	REQ_QUERY
	RESP_LENGTH
	RESP_ROUNDTRIP_TIME
	RESP_STATUS_CODE
}

input InterceptEntryOrderInput {
	by: InterceptEntryOrderBy!
	ordering: Ordering!
}

enum InterceptKind {
	REQUEST
	RESPONSE
}

interface InterceptMessage {
	id: ID!
}

type InterceptMessageConnection {
	count: Count!
	"""
	A list of edges.
	"""
	edges: [InterceptMessageEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [InterceptMessage!]!
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	snapshot: Snapshot!
}

"""
An edge in a connection.
"""
type InterceptMessageEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: InterceptMessage!
}

type InterceptOptions {
	request: InterceptRequestOptions!
	response: InterceptResponseOptions!
	scope: InterceptScopeOptions
}

input InterceptOptionsInput {
	request: InterceptRequestOptionsInput!
	response: InterceptResponseOptionsInput!
	scope: InterceptScopeOptionsInput
}

type InterceptRequestMessage implements InterceptMessage {
	id: ID!
	request: Request!
}

type InterceptRequestOptions {
	enabled: Boolean!
}

input InterceptRequestOptionsInput {
	enabled: Boolean!
}

type InterceptResponseMessage implements InterceptMessage {
	id: ID!
	request: Request!
	response: Response!
}

type InterceptResponseOptions {
	enabled: Boolean!
}

input InterceptResponseOptionsInput {
	enabled: Boolean!
}

type InterceptScopeOptions {
	scopeId: ID!
}

input InterceptScopeOptionsInput {
	scopeId: ID!
}

enum InterceptStatus {
	PAUSED
	RUNNING
}

type InternalUserError implements UserError {
	code: String!
	message: String!
}

type InvalidGlobTermsUserError implements UserError {
	code: String!
	terms: [String!]!
}

type InvalidHTTPQLUserError implements UserError {
	code: String!
	query: String!
}

type InvalidRegexUserError implements UserError {
	code: String!
	term: String!
}

"""
A scalar that can represent any JSON value.
"""
scalar JSON

scalar JsonObject

scalar JsonRaw

union LocalizeWorkflowError = UnknownIdUserError | ReadOnlyUserError | WorkflowUserError | OtherUserError

type LocalizeWorkflowPayload {
	error: LocalizeWorkflowError
	workflow: Workflow
}

type LogoutPayload {
	success: Boolean!
}

type MoveReplaySessionPayload {
	session: ReplaySession
}

type MoveTamperRulePayload {
	rule: TamperRule
}

type MutationRoot {
	cancelAutomateTask(id: ID!): CancelAutomateTaskPayload!
	cancelBackupTask(id: ID!): CancelBackupTaskPayload!
	cancelDataExportTask(id: ID!): CancelDataExportTaskPayload!
	cancelRestoreBackupTask(id: ID!): CancelRestoreBackupTaskPayload!
	cancelTask(id: ID!): CancelTaskPayload!
	createAssistantSession(input: CreateAssistantSessionInput!): CreateAssistantSessionPayload!
	createAutomateSession(input: CreateAutomateSessionInput!): CreateAutomateSessionPayload!
	createBackup(projectId: ID!): CreateBackupPayload!
	createFilterPreset(input: CreateFilterPresetInput!): CreateFilterPresetPayload!
	createFinding(requestId: ID!, input: CreateFindingInput!): CreateFindingPayload!
	createProject(input: CreateProjectInput!): CreateProjectPayload!
	createReplaySession(input: CreateReplaySessionInput!): CreateReplaySessionPayload!
	createReplaySessionCollection(input: CreateReplaySessionCollectionInput!): CreateReplaySessionCollectionPayload!
	createScope(input: CreateScopeInput!): CreateScopePayload!
	createSitemapEntries(requestId: ID!): CreateSitemapEntriesPayload!
	createTamperRule(input: CreateTamperRuleInput!): CreateTamperRulePayload!
	createTamperRuleCollection(input: CreateTamperRuleCollectionInput!): CreateTamperRuleCollectionPayload!
	createUpstreamProxyHttp(input: CreateUpstreamProxyHttpInput!): CreateUpstreamProxyHttpPayload!
	createUpstreamProxySocks(input: CreateUpstreamProxySocksInput!): CreateUpstreamProxySocksPayload!
	createWorkflow(input: CreateWorkflowInput!): CreateWorkflowPayload!
	deleteAssistantSession(id: ID!): DeleteAssistantSessionPayload!
	deleteAutomateEntries(ids: [ID!]!): DeleteAutomateEntriesPayload!
	deleteAutomateSession(id: ID!): DeleteAutomateSessionPayload!
	deleteBackup(id: ID!): DeleteBackupPayload!
	deleteBrowser: DeleteBrowserPayload!
	deleteDataExport(id: ID!): DeleteDataExportPayload!
	deleteFilterPreset(id: ID!): DeleteFilterPresetPayload!
	deleteFindings(ids: [ID!]!): DeleteFindingsPayload!
	deleteHostedFile(id: ID!): DeleteHostedFilePayload!
	deleteInterceptEntries(filter: HTTPQL, scopeId: ID): DeleteInterceptEntriesPayload!
	deleteInterceptEntry(id: ID!): DeleteInterceptEntryPayload!
	deleteProject(id: ID!): DeleteProjectPayload!
	deleteReplaySessionCollection(id: ID!): DeleteReplaySessionCollectionPayload!
	deleteReplaySessions(ids: [ID!]!): DeleteReplaySessionsPayload!
	deleteScope(id: ID!): DeleteScopePayload!
	deleteTamperRule(id: ID!): DeleteTamperRulePayload!
	deleteTamperRuleCollection(id: ID!): DeleteTamperRuleCollectionPayload!
	deleteUpstreamProxyHttp(id: ID!): DeleteUpstreamProxyHttpPayload!
	deleteUpstreamProxySocks(id: ID!): DeleteUpstreamProxySocksPayload!
	deleteWorkflow(id: ID!): DeleteWorkflowPayload!
	disableTamperRule(id: ID!): DisableTamperRulePayload!
	dropInterceptMessage(id: ID!): DropInterceptMessagePayload!
	duplicateAutomateSession(id: ID!): DuplicateAutomateSessionPayload!
	enableTamperRule(id: ID!): EnableTamperRulePayload!
	forwardInterceptMessage(id: ID!, input: ForwardInterceptMessageInput): ForwardInterceptMessagePayload!
	globalizeWorkflow(id: ID!): GlobalizeWorkflowPayload!
	installBrowser: InstallBrowserPayload!
	installPluginPackage(input: InstallPluginPackageInput!): InstallPluginPackagePayload!
	localizeWorkflow(id: ID!): LocalizeWorkflowPayload!
	logout: LogoutPayload!
	moveReplaySession(id: ID!, collectionId: ID!): MoveReplaySessionPayload!
	moveTamperRule(id: ID!, collectionId: ID!): MoveTamperRulePayload!
	pauseAutomateTask(id: ID!): PauseAutomateTaskPayload!
	pauseIntercept: PauseInterceptPayload!
	rankTamperRule(id: ID!, input: RankTamperRuleInput!): RankTamperRulePayload!
	rankUpstreamProxyHttp(id: ID!, input: RankUpstreamProxyHttpInput!): RankUpstreamProxyHttpPayload!
	rankUpstreamProxySocks(id: ID!, input: RankUpstreamProxySocksInput!): RankUpstreamProxySocksPayload!
	refreshAuthenticationToken(refreshToken: Token!): RefreshAuthenticationTokenPayload!
	renameAssistantSession(id: ID!, name: String!): RenameAssistantSessionPayload!
	renameAutomateEntry(id: ID!, name: String!): RenameAutomateEntryPayload!
	renameAutomateSession(id: ID!, name: String!): RenameAutomateSessionPayload!
	renameBackup(id: ID!, name: String!): RenameBackupPayload!
	renameDataExport(id: ID!, name: String!): RenameDataExportPayload!
	renameHostedFile(id: ID!, name: String!): RenameHostedFilePayload!
	renameProject(id: ID!, name: String!): RenameProjectPayload!
	renameReplaySession(id: ID!, name: String!): RenameReplaySessionPayload!
	renameReplaySessionCollection(id: ID!, name: String!): RenameReplaySessionCollectionPayload!
	renameScope(id: ID!, name: String!): RenameScopePayload!
	renameTamperRule(id: ID!, name: String!): RenameTamperRulePayload!
	renameTamperRuleCollection(id: ID!, name: String!): RenameTamperRuleCollectionPayload!
	renameWorkflow(id: ID!, name: String!): RenameWorkflowPayload!
	renderRequest(id: ID!, input: RenderRequestInput!): RenderRequestPayload!
	restoreBackup(input: RestoreBackupInput!): RestoreBackupPayload!
	resumeAutomateTask(id: ID!): ResumeAutomateTaskPayload!
	resumeIntercept: ResumeInterceptPayload!
	runActiveWorkflow(id: ID!, input: RunActiveWorkflowInput!): RunActiveWorkflowPayload!
	runConvertWorkflow(id: ID!, input: Blob!): RunConvertWorkflowPayload!
	selectProject(id: ID!): SelectProjectPayload!
	sendAssistantMessage(sessionId: ID!, message: String): SendAssistantMessagePayload!
	setActiveReplaySessionEntry(id: ID!, entryId: ID!): SetActiveReplaySessionEntryPayload! @deprecated(reason: "Remove usage, no replacement")
	setGlobalConfigOnboarding(input: SetConfigOnboardingInput!): SetConfigOnboardingPayload!
	setGlobalConfigPort(input: Int!): SetConfigPortPayload!
	setInterceptOptions(input: InterceptOptionsInput!): SetInterceptOptionsPayload!
	setPluginData(id: ID!, data: JSON!): SetPluginDataPayload!
	startAuthenticationFlow: StartAuthenticationFlowPayload!
	startAutomateTask(automateSessionId: ID!): StartAutomateTaskPayload!
	startExportRequestsTask(input: StartExportRequestsTaskInput!): StartExportRequestsTaskPayload!
	startReplayTask(sessionId: ID!, input: StartReplayTaskInput!): StartReplayTaskPayload!
	testTamperRule(input: TestTamperRuleInput!): TestTamperRulePayload!
	testUpstreamProxyHttp(input: TestUpstreamProxyHttpInput!): TestUpstreamProxyHttpPayload!
	testUpstreamProxySocks(input: TestUpstreamProxySocksInput!): TestUpstreamProxySocksPayload!
	togglePlugin(id: ID!, enabled: Boolean!): TogglePluginPayload!
	toggleUpstreamProxyHttp(id: ID!, enabled: Boolean!): ToggleUpstreamProxyHttpPayload!
	toggleUpstreamProxySocks(id: ID!, enabled: Boolean!): ToggleUpstreamProxySocksPayload!
	toggleWorkflow(id: ID!, enabled: Boolean!): ToggleWorkflowPayload!
	uninstallPluginPackage(id: ID!): UninstallPluginPackagePayload!
	updateAutomateSession(id: ID!, input: UpdateAutomateSessionInput!): UpdateAutomateSessionPayload!
	updateBrowser: UpdateBrowserPayload!
	updateFilterPreset(id: ID!, input: UpdateFilterPresetInput!): UpdateFilterPresetPayload!
	updateRequestMetadata(id: ID!, input: UpdateRequestMetadataInput!): UpdateRequestMetadataPayload!
	updateScope(id: ID!, input: UpdateScopeInput!): UpdateScopePayload!
	updateTamperRule(id: ID!, input: UpdateTamperRuleInput!): UpdateTamperRulePayload!
	updateUpstreamProxyHttp(id: ID!, input: UpdateUpstreamProxyHttpInput!): UpdateUpstreamProxyHttpPayload!
	updateUpstreamProxySocks(id: ID!, input: UpdateUpstreamProxySocksInput!): UpdateUpstreamProxySocksPayload!
	updateViewerSettings(input: UpdateViewerSettingsInput!): UpdateViewerSettingsPayload!
	updateWorkflow(id: ID!, input: UpdateWorkflowInput!): UpdateWorkflowPayload!
	uploadHostedFile(input: UploadHostedFileInput!): UploadHostedFilePayload!
}

type NameTakenUserError implements UserError {
	code: String!
	name: String!
}

type OnboardingState {
	caCertificate: Boolean!
	license: Boolean!
	project: Boolean!
}

enum Ordering {
	ASC
	DESC
}

type OtherUserError implements UserError {
	code: String!
}

"""
Information about pagination in a connection
"""
type PageInfo {
	"""
	When paginating forwards, the cursor to continue.
	"""
	endCursor: String
	"""
	When paginating forwards, are there more items?
	"""
	hasNextPage: Boolean!
	"""
	When paginating backwards, are there more items?
	"""
	hasPreviousPage: Boolean!
	"""
	When paginating backwards, the cursor to continue.
	"""
	startCursor: String
}

union PauseAutomateTaskError = UnknownIdUserError | OtherUserError

type PauseAutomateTaskPayload {
	automateTask: AutomateTask
	userError: PauseAutomateTaskError
}

type PauseInterceptPayload {
	status: InterceptStatus!
}

enum PermissionDeniedErrorReason {
	ENTITLEMENT
}

type PermissionDeniedUserError implements UserError {
	code: String!
	reason: PermissionDeniedErrorReason!
}

interface Plugin {
	enabled: Boolean!
	id: ID!
	manifestId: ID!
	name: String
	package: PluginPackage!
}

type PluginAuthor {
	email: String
	name: String
	url: String
}

type PluginBackend implements Plugin {
	enabled: Boolean!
	id: ID!
	manifestId: ID!
	name: String
	package: PluginPackage!
	runtime: PluginRuntime!
	state: PluginState!
}

enum PluginErrorReason {
	ALREADY_INSTALLED
	INVALID_MANIFEST
	INVALID_OPERATION
	INVALID_PACKAGE
	MISSING_FILE
}

type PluginFrontend implements Plugin {
	backend: PluginBackend
	data: JSON
	enabled: Boolean!
	entrypoint: String
	id: ID!
	manifestId: ID!
	name: String
	package: PluginPackage!
	style: String
}

type PluginPackage {
	author: PluginAuthor
	description: String
	id: ID!
	installedAt: DateTime!
	manifestId: ID!
	name: String
	plugins: [Plugin!]!
	version: String!
}

input PluginPackageSource @oneOf {
	file: Upload
	manifestId: ID
}

enum PluginRuntime {
	JAVASCRIPT
}

type PluginState {
	error: String
	running: Boolean!
}

type PluginUserError implements UserError {
	code: String!
	reason: PluginErrorReason!
}

type PluginWorkflow implements Plugin {
	enabled: Boolean!
	id: ID!
	manifestId: ID!
	name: String
	package: PluginPackage!
	workflow: Workflow
}

scalar Port

type Project {
	backups: [Backup!]!
	createdAt: DateTime!
	id: ID!
	name: String!
	path: String!
	size: Int!
	status: ProjectStatus!
	updatedAt: DateTime!
	version: String!
}

enum ProjectErrorReason {
	DELETING
	EXPORTING
	INVALID_VERSION
	NOT_READY
	TOO_RECENT
}

enum ProjectStatus {
	ERROR
	READY
	RESTORING
}

type ProjectUserError implements UserError {
	code: String!
	reason: ProjectErrorReason!
}

type QueryRoot {
	assistantModels: [AssistantModel!]!
	assistantSession(id: ID!): AssistantSession
	assistantSessions: [AssistantSession!]!
	automateEntry(id: ID!): AutomateEntry
	automateSession(id: ID!): AutomateSession
	automateSessions(after: String, before: String, first: Int, last: Int): AutomateSessionConnection!
	automateTasks(after: String, before: String, first: Int, last: Int): AutomateTaskConnection!
	backup(id: ID!): Backup
	backupTasks: [BackupTask!]!
	backups: [Backup!]!
	browser: Browser
	currentProject: Project
	dataExport(id: ID!): DataExport
	dataExportTasks: [DataExportTask!]!
	dataExports: [DataExport!]!
	filterPreset(id: ID!): FilterPreset
	filterPresets: [FilterPreset!]!
	finding(id: ID!): Finding
	findingReporters: [String!]!
	findings(after: String, before: String, first: Int, last: Int, filter: FilterClauseFindingInput, order: FindingOrderInput): FindingConnection!
	findingsByOffset(limit: Int, offset: Int, filter: FilterClauseFindingInput, order: FindingOrderInput): FindingConnection!
	globalConfig: GlobalConfig!
	hostedFiles: [HostedFile!]!
	interceptEntries(after: String, before: String, first: Int, last: Int, filter: HTTPQL, order: InterceptEntryOrderInput, scopeId: ID): InterceptEntryConnection!
	interceptEntriesByOffset(limit: Int, offset: Int, filter: HTTPQL, order: InterceptEntryOrderInput, scopeId: ID): InterceptEntryConnection!
	interceptEntry(id: ID!): InterceptEntry
	interceptMessages(after: String, before: String, first: Int, last: Int, kind: InterceptKind!): InterceptMessageConnection!
	interceptOptions: InterceptOptions!
	interceptStatus: InterceptStatus!
	pluginPackages: [PluginPackage!]!
	projects: [Project!]!
	replayEntry(id: ID!): ReplayEntry
	replaySession(id: ID!): ReplaySession
	replaySessionCollections(after: String, before: String, first: Int, last: Int): ReplaySessionCollectionConnection!
	replaySessions(after: String, before: String, first: Int, last: Int): ReplaySessionConnection!
	request(id: ID!): Request
	requests(after: String, before: String, first: Int, last: Int, filter: HTTPQL, order: RequestResponseOrderInput, scopeId: ID): RequestConnection!
	requestsByOffset(limit: Int, offset: Int, filter: HTTPQL, order: RequestResponseOrderInput, scopeId: ID): RequestConnection!
	response(id: ID!): Response
	restoreBackupTasks: [RestoreBackupTask!]!
	runtime: Runtime!
	scope(id: ID!): Scope
	scopes: [Scope!]!
	sitemapDescendantEntries(parentId: ID!, depth: SitemapDescendantsDepth!): SitemapEntryConnection!
	sitemapEntry(id: ID!): SitemapEntry
	sitemapRootEntries(scopeId: ID): SitemapEntryConnection!
	store: Store!
	stream(id: ID!): Stream
	streamWsMessage(id: ID!): StreamWsMessage
	streamWsMessages(after: String, before: String, first: Int, last: Int, order: StreamWsMessageOrderInput, streamId: ID!): StreamWsMessageConnection!
	streamWsMessagesByOffset(limit: Int, offset: Int, order: StreamWsMessageOrderInput, streamId: ID!): StreamWsMessageConnection!
	streams(after: String, before: String, first: Int, last: Int, protocol: StreamProtocol!, order: StreamOrderInput, scopeId: ID): StreamConnection!
	streamsByOffset(limit: Int, offset: Int, protocol: StreamProtocol!, order: StreamOrderInput, scopeId: ID): StreamConnection!
	tamperRule(id: ID!): TamperRule
	tamperRuleCollection(id: ID!): TamperRuleCollection
	tamperRuleCollections(after: String, before: String, first: Int, last: Int): TamperRuleCollectionConnection!
	tasks: [Task!]!
	upstreamProxiesHttp: [UpstreamProxyHttp!]!
	upstreamProxiesSocks: [UpstreamProxySocks!]!
	viewer: User!
	workflow(id: ID!): Workflow
	workflowNodeDefinitions: [WorkflowNodeDefinition!]!
	workflows: [Workflow!]!
}

type Range {
	end: Int!
	start: Int!
}

input RangeInput {
	end: Int!
	start: Int!
}

scalar Rank

input RankTamperRuleInput {
	afterId: ID
	beforeId: ID
}

type RankTamperRulePayload {
	rule: TamperRule
}

input RankUpstreamProxyHttpInput {
	afterId: ID
	beforeId: ID
}

type RankUpstreamProxyHttpPayload {
	proxy: UpstreamProxyHttp
}

input RankUpstreamProxySocksInput {
	afterId: ID
	beforeId: ID
}

type RankUpstreamProxySocksPayload {
	proxy: UpstreamProxySocks
}

type ReadOnlyUserError implements UserError {
	code: String!
}

union RefreshAuthenticationTokenError = AuthenticationUserError | OtherUserError

type RefreshAuthenticationTokenPayload {
	error: RefreshAuthenticationTokenError
	token: AuthenticationToken
}

type Release {
	links: [ReleaseLink!]!
	releasedAt: DateTime!
	version: String!
}

type ReleaseLink {
	display: String!
	link: String!
	platform: String!
}

type RenameAssistantSessionPayload {
	session: AssistantSession
}

type RenameAutomateEntryPayload {
	entry: AutomateEntry
}

type RenameAutomateSessionPayload {
	session: AutomateSession
}

type RenameBackupPayload {
	backup: Backup
}

type RenameDataExportPayload {
	export: DataExport
}

type RenameHostedFilePayload {
	hostedFile: HostedFile
}

type RenameProjectPayload {
	error: RenameProjectPayloadError
	project: Project
}

union RenameProjectPayloadError = NameTakenUserError | OtherUserError

type RenameReplaySessionCollectionPayload {
	collection: ReplaySessionCollection
}

type RenameReplaySessionPayload {
	session: ReplaySession
}

type RenameScopePayload {
	scope: Scope!
}

type RenameTamperRuleCollectionPayload {
	collection: TamperRuleCollection
}

type RenameTamperRulePayload {
	rule: TamperRule
}

union RenameWorkflowError = UnknownIdUserError | ReadOnlyUserError | OtherUserError

type RenameWorkflowPayload {
	error: RenameWorkflowError
	workflow: Workflow
}

enum RenderFailedErrorReason {
	INTERNAL
	NO_BROWSER
	NO_DATA
	TIMEOUT
}

type RenderFailedUserError implements UserError {
	code: String!
	reason: RenderFailedErrorReason!
}

union RenderRequestError = RenderFailedUserError | OtherUserError

input RenderRequestInput {
	height: Int!
	width: Int!
}

type RenderRequestPayload {
	error: RenderRequestError
	render: Image
}

type ReplayEntry {
	connection: ConnectionInfo!
	createdAt: Timestamp!
	error: String
	id: ID!
	raw: Blob!
	request: Request
	session: ReplaySession!
	settings: ReplayEntrySettings!
}

type ReplayEntryConnection {
	count: Count!
	"""
	A list of edges.
	"""
	edges: [ReplayEntryEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [ReplayEntry!]!
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	snapshot: Snapshot!
}

"""
An edge in a connection.
"""
type ReplayEntryEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: ReplayEntry!
}

enum ReplayEntryOrderBy {
	ID
}

input ReplayEntryOrderInput {
	by: ReplayEntryOrderBy!
	ordering: Ordering!
}

type ReplayEntrySettings {
	placeholders: [ReplayPlaceholder!]!
}

input ReplayEntrySettingsInput {
	placeholders: [ReplayPlaceholderInput!]!
	updateContentLength: Boolean!
}

type ReplayPlaceholder {
	inputRange: Range!
	outputRange: Range!
	preprocessors: [ReplayPreprocessor!]!
}

input ReplayPlaceholderInput {
	inputRange: RangeInput!
	outputRange: RangeInput!
	preprocessors: [ReplayPreprocessorInput!]!
}

type ReplayPrefixPreprocessor {
	value: String!
}

input ReplayPrefixPreprocessorInput {
	value: String!
}

type ReplayPreprocessor {
	options: ReplayPreprocessorOptions!
}

input ReplayPreprocessorInput {
	options: ReplayPreprocessorOptionsInput!
}

union ReplayPreprocessorOptions = ReplayPrefixPreprocessor | ReplaySuffixPreprocessor | ReplayUrlEncodePreprocessor | ReplayWorkflowPreprocessor

input ReplayPreprocessorOptionsInput @oneOf {
	prefix: ReplayPrefixPreprocessorInput
	suffix: ReplaySuffixPreprocessorInput
	urlEncode: ReplayUrlEncodePreprocessorInput
	workflow: ReplayWorkflowPreprocessorInput
}

type ReplaySession {
	activeEntry: ReplayEntry
	collection: ReplaySessionCollection!
	entries(after: String, before: String, first: Int, last: Int, order: ReplayEntryOrderInput): ReplayEntryConnection!
	id: ID!
	name: String!
}

type ReplaySessionCollection {
	id: ID!
	name: String!
	sessions: [ReplaySession!]!
}

type ReplaySessionCollectionConnection {
	count: Count!
	"""
	A list of edges.
	"""
	edges: [ReplaySessionCollectionEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [ReplaySessionCollection!]!
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	snapshot: Snapshot!
}

"""
An edge in a connection.
"""
type ReplaySessionCollectionEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: ReplaySessionCollection!
}

type ReplaySessionConnection {
	count: Count!
	"""
	A list of edges.
	"""
	edges: [ReplaySessionEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [ReplaySession!]!
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	snapshot: Snapshot!
}

"""
An edge in a connection.
"""
type ReplaySessionEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: ReplaySession!
}

type ReplaySuffixPreprocessor {
	value: String!
}

input ReplaySuffixPreprocessorInput {
	value: String!
}

type ReplayTask implements Task {
	createdAt: DateTime!
	id: ID!
	replayEntry: ReplayEntry!
}

type ReplayUrlEncodePreprocessor {
	charset: String
	nonAscii: Boolean!
}

input ReplayUrlEncodePreprocessorInput {
	charset: String
	nonAscii: Boolean!
}

type ReplayWorkflowPreprocessor {
	id: ID!
}

input ReplayWorkflowPreprocessorInput {
	id: ID!
}

type Request {
	alteration: Alteration!
	createdAt: Timestamp!
	edited: Boolean!
	edits: [Request!]!
	fileExtension: String
	host: String!
	id: ID!
	isTls: Boolean!
	length: Int!
	metadata: RequestMetadata!
	method: String!
	path: String!
	port: Port!
	query: String!
	raw: Blob!
	response: Response
	source: Source!
	stream: Stream
}

type RequestConnection {
	count: Count!
	"""
	A list of edges.
	"""
	edges: [RequestEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Request!]!
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	snapshot: Snapshot!
}

"""
An edge in a connection.
"""
type RequestEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: Request!
}

type RequestMetadata {
	color: String
	id: ID!
}

input RequestRawInput {
	connectionInfo: ConnectionInfoInput!
	raw: Blob!
}

enum RequestResponseOrderBy {
	CREATED_AT
	FILE_EXTENSION
	HOST
	ID
	METHOD
	PATH
	QUERY
	RESP_LENGTH
	RESP_ROUNDTRIP_TIME
	RESP_STATUS_CODE
	SOURCE
}

input RequestResponseOrderInput {
	by: RequestResponseOrderBy!
	ordering: Ordering!
}

input RequestSourceInput @oneOf {
	id: ID
	raw: RequestRawInput
}

type Response {
	alteration: Alteration!
	createdAt: Timestamp!
	edited: Boolean!
	edits: [Response!]!
	id: ID!
	length: Int!
	raw: Blob!
	roundtripTime: Int!
	statusCode: Int!
}

union RestoreBackupError = NameTakenUserError | PermissionDeniedUserError | OtherUserError

input RestoreBackupInput {
	name: String!
	source: BackupSource!
}

type RestoreBackupPayload {
	error: RestoreBackupError
	task: RestoreBackupTask
}

type RestoreBackupTask {
	backup: Backup
	id: ID!
	project: Project!
}

union RestoreBackupTaskError = BackupUserError | InternalUserError | OtherUserError

union ResumeAutomateTaskError = UnknownIdUserError | OtherUserError

type ResumeAutomateTaskPayload {
	automateTask: AutomateTask
	userError: ResumeAutomateTaskError
}

type ResumeInterceptPayload {
	status: InterceptStatus!
}

union RunActiveWorkflowError = UnknownIdUserError | PermissionDeniedUserError | OtherUserError

input RunActiveWorkflowInput {
	requestId: ID!
}

type RunActiveWorkflowPayload {
	error: RunActiveWorkflowError
	task: WorkflowTask
}

union RunConvertWorkflowError = WorkflowUserError | PermissionDeniedUserError | OtherUserError

type RunConvertWorkflowPayload {
	error: RunConvertWorkflowError
	output: Blob
}

type Runtime {
	availableUpdate: Release
	logs: Uri!
	platform: String!
	version: String!
}

type Scope {
	allowlist: [String!]!
	denylist: [String!]!
	id: ID!
	indexed: Boolean!
	name: String!
}

"""
An edge in a connection.
"""
type ScopeEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: Scope!
}

type SelectProjectPayload {
	error: SelectProjectPayloadError
	project: Project
}

union SelectProjectPayloadError = ProjectUserError | UnknownIdUserError | OtherUserError

union SendAssistantMessageError = PermissionDeniedUserError | TaskInProgressUserError | OtherUserError

type SendAssistantMessagePayload {
	error: SendAssistantMessageError
	task: AssistantMessageTask
}

scalar Sensitive

type SetActiveReplaySessionEntryPayload {
	session: ReplaySession
}

input SetConfigOnboardingInput {
	caCertificate: Boolean!
	license: Boolean!
	project: Boolean!
}

type SetConfigOnboardingPayload {
	config: GlobalConfig!
}

type SetConfigPortPayload {
	config: GlobalConfig!
}

type SetInterceptOptionsPayload {
	options: InterceptOptions!
}

union SetPluginDataError = UnknownIdUserError | PluginUserError | OtherUserError

type SetPluginDataPayload {
	error: SetPluginDataError
	plugin: Plugin
}

enum SitemapDescendantsDepth {
	ALL
	DIRECT
}

type SitemapEntry {
	hasDescendants: Boolean!
	id: ID!
	kind: SitemapEntryKind!
	label: String!
	metadata: SitemapEntryMetadata
	parentId: ID
	request: Request
	requests(after: String, before: String, first: Int, last: Int, order: RequestResponseOrderInput): RequestConnection!
}

type SitemapEntryConnection {
	count: Count!
	"""
	A list of edges.
	"""
	edges: [SitemapEntryEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [SitemapEntry!]!
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	snapshot: Snapshot!
}

"""
An edge in a connection.
"""
type SitemapEntryEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: SitemapEntry!
}

enum SitemapEntryKind {
	DIRECTORY
	DOMAIN
	REQUEST
	REQUEST_BODY
	REQUEST_QUERY
}

union SitemapEntryMetadata = SitemapEntryMetadataDomain

type SitemapEntryMetadataDomain {
	isTls: Boolean!
	port: Port!
}

scalar Snapshot

enum Source {
	AUTOMATE
	INTERCEPT
	REPLAY
	WORKFLOW
}

union StartAuthenticationFlowError = AuthenticationUserError | OtherUserError

type StartAuthenticationFlowPayload {
	error: StartAuthenticationFlowError
	request: AuthenticationRequest
}

type StartAutomateTaskPayload {
	automateTask: AutomateTask
}

input StartExportRequestsTaskInput {
	filter: HTTPQL
	format: DataExportFormat!
	scopeId: ID
	settings: DataExportSettings!
}

type StartExportRequestsTaskPayload {
	error: StartExportRequestsTaskPayloadError
	task: DataExportTask
}

union StartExportRequestsTaskPayloadError = PermissionDeniedUserError | OtherUserError

union StartReplayTaskError = TaskInProgressUserError | PermissionDeniedUserError | OtherUserError

input StartReplayTaskInput {
	connection: ConnectionInfoInput!
	raw: Blob!
	settings: ReplayEntrySettingsInput!
}

type StartReplayTaskPayload {
	error: StartReplayTaskError
	task: ReplayTask
}

type StartedBackupTaskPayload {
	task: BackupTask!
}

type StartedDeleteInterceptEntriesTaskPayload {
	task: DeleteInterceptEntriesTask!
}

type StartedRestoreBackupTaskPayload {
	task: RestoreBackupTask!
}

type StartedTaskPayload {
	task: Task!
}

type Store {
	pluginPackages: [StorePluginPackage!]!
}

enum StoreErrorReason {
	FILE_UNAVAILABLE
	INVALID_PUBLIC_KEY
	INVALID_SIGNATURE
	PACKAGE_TOO_LARGE
	PACKAGE_UNKNOWN
}

type StorePluginPackage {
	author: StorePluginPackageAuthor
	description: String
	license: String!
	manifestId: ID!
	name: String
	repository: Url!
	version: Version!
}

type StorePluginPackageAuthor {
	email: String
	name: String
	url: String
}

type StoreUserError implements UserError {
	code: String!
	reason: StoreErrorReason!
}

type Stream {
	createdAt: Timestamp!
	direction: StreamDirection!
	host: String!
	id: ID!
	isTls: Boolean!
	path: String!
	port: Port!
	protocol: StreamProtocol!
	source: Source!
}

type StreamConnection {
	count: Count!
	"""
	A list of edges.
	"""
	edges: [StreamEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Stream!]!
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	snapshot: Snapshot!
}

enum StreamDirection {
	BOTH
	CLIENT
	SERVER
}

"""
An edge in a connection.
"""
type StreamEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: Stream!
}

enum StreamMessageDirection {
	CLIENT
	SERVER
}

enum StreamOrderBy {
	ID
}

input StreamOrderInput {
	by: StreamOrderBy!
	ordering: Ordering!
}

enum StreamProtocol {
	SSE
	WS
}

type StreamWsMessage {
	alteration: Alteration!
	createdAt: Timestamp!
	direction: StreamMessageDirection!
	edited: Boolean!
	format: StreamWsMessageFormat!
	id: ID!
	length: Int!
	raw: Blob!
	streamId: ID!
}

type StreamWsMessageConnection {
	count: Count!
	"""
	A list of edges.
	"""
	edges: [StreamWsMessageEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [StreamWsMessage!]!
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	snapshot: Snapshot!
}

"""
An edge in a connection.
"""
type StreamWsMessageEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: StreamWsMessage!
}

enum StreamWsMessageFormat {
	BINARY
	TEXT
}

enum StreamWsMessageOrderBy {
	ID
}

input StreamWsMessageOrderInput {
	by: StreamWsMessageOrderBy!
	ordering: Ordering!
}


type SubscriptionRoot {
	createdAssistantMessage: CreatedAssistantMessagePayload!
	createdAssistantMessageTask: CreatedAssistantMessageTaskPayload!
	createdAssistantSession: CreatedAssistantSessionPayload!
	createdAuthenticationToken(requestId: ID!): CreatedAuthenticationTokenPayload!
	createdAutomateEntry: CreatedAutomateEntryPayload!
	createdAutomateEntryRequest(filter: HTTPQL): CreatedAutomateEntryRequestPayload!
	createdAutomateSession: CreatedAutomateSessionPayload!
	createdAutomateTask: CreatedAutomateTaskPayload!
	createdBackup: CreatedBackupPayload!
	createdDataExport: CreatedDataExportPayload!
	createdDataExportTask: CreatedDataExportTaskPayload!
	createdFilterPreset: CreatedFilterPresetPayload!
	createdFinding: CreatedFindingPayload!
	createdInterceptEntry(filter: HTTPQL, scopeId: ID): CreatedInterceptEntryPayload!
	createdInterceptMessage: CreatedInterceptMessagePayload!
	createdPluginEvent: CreatedPluginEventPayload!
	createdPluginPackage: CreatedPluginPackagePayload!
	createdProject: CreatedProjectPayload!
	createdReplaySession: CreatedReplaySessionPayload!
	createdReplaySessionCollection: CreatedReplaySessionCollectionPayload!
	createdRequest(filter: HTTPQL, scopeId: ID): CreatedRequestPayload!
	createdScope: CreatedScopePayload!
	createdSitemapEntry(scopeId: ID): CreatedSitemapEntryPayload!
	createdStream(protocol: StreamProtocol!, scopeId: ID): CreatedStreamPayload!
	createdStreamWsMessage: CreatedStreamWsMessagePayload!
	createdTamperRule: CreatedTamperRulePayload!
	createdTamperRuleCollection: CreatedTamperRuleCollectionPayload!
	createdUpstreamProxyHttp: CreatedUpstreamProxyHttpPayload!
	createdUpstreamProxySocks: CreatedUpstreamProxySocksPayload!
	createdWorkflow: CreatedWorkflowPayload!
	deletedAssistantSession: DeletedAssistantSessionPayload!
	deletedAutomateEntry: DeletedAutomateEntryPayload!
	deletedAutomateSession: DeletedAutomateSessionPayload!
	deletedAutomateTask: DeletedAutomateTaskPayload!
	deletedBackup: DeletedBackupPayload!
	deletedBrowser: DeletedBrowserPayload!
	deletedDataExport: DeletedDataExportPayload!
	deletedDataExportTask: DeletedDataExportTaskPayload!
	deletedFilterPreset: DeletedFilterPresetPayload!
	deletedFindings: DeletedFindingsPayload!
	deletedHostedFile: DeletedHostedFilePayload!
	deletedInterceptEntry: DeletedInterceptEntryPayload!
	deletedInterceptMessage: DeletedInterceptMessagePayload!
	deletedPluginPackage: DeletedPluginPackagePayload!
	deletedProject: DeletedProjectPayload!
	deletedReplaySession: DeletedReplaySessionPayload!
	deletedReplaySessionCollection: DeletedReplaySessionCollectionPayload!
	deletedScope: DeletedScopePayload!
	deletedTamperRule: DeletedTamperRulePayload!
	deletedTamperRuleCollection: DeletedTamperRuleCollectionPayload!
	deletedUpstreamProxyHttp: DeletedUpstreamProxyHttpPayload!
	deletedUpstreamProxySocks: DeletedUpstreamProxySocksPayload!
	deletedWorkflow: DeletedWorkflowPayload!
	finishedBackupTask: FinishedBackupTaskPayload!
	finishedDeleteInterceptEntriesTask: FinishedDeleteInterceptEntriesTaskPayload!
	finishedRestoreBackupTask: FinishedRestoreBackupTaskPayload!
	finishedTask: FinishedTaskPayload!
	installedBrowser: UploadedBrowserPayload!
	startedBackupTask: StartedBackupTaskPayload!
	startedDeleteInterceptEntriesTask: StartedDeleteInterceptEntriesTaskPayload!
	startedRestoreBackupTask: StartedRestoreBackupTaskPayload!
	startedTask: StartedTaskPayload!
	updatedAssistantMessageTask: UpdatedAssistantMessageTaskPayload!
	updatedAssistantSession: UpdatedAssistantSessionPayload!
	updatedAutomateEntry: UpdatedAutomateEntryPayload!
	updatedAutomateSession: UpdatedAutomateSessionPayload!
	updatedAutomateTask: UpdatedAutomateTaskPayload!
	updatedBackup: UpdatedBackupPayload!
	updatedBrowser: UpdatedBrowserPayload!
	updatedDataExport: UpdatedDataExportPayload!
	updatedDeleteInterceptEntriesTask: UpdatedDeleteInterceptEntriesTaskPayload!
	updatedFilterPreset: UpdatedFilterPresetPayload!
	updatedHostedFile: UpdatedHostedFilePayload!
	updatedInterceptEntry(filter: HTTPQL, scopeId: ID): UpdatedInterceptEntryPayload!
	updatedInterceptOptions: UpdatedInterceptOptionsPayload!
	updatedInterceptStatus: UpdatedInterceptStatusPayload!
	updatedPlugin: UpdatedPluginPayload!
	updatedPluginPackage: UpdatedPluginPackagePayload!
	updatedProject: UpdatedProjectPayload!
	updatedReplaySession: UpdatedReplaySessionPayload!
	updatedReplaySessionCollection: UpdatedReplaySessionCollectionPayload!
	updatedRequest(filter: HTTPQL, scopeId: ID): UpdatedRequestPayload!
	updatedRequestMetadata: UpdatedRequestMetadataPayload!
	updatedScope: UpdatedScopePayload!
	updatedSitemapEntry(scopeId: ID): UpdatedSitemapEntryPayload!
	updatedTamperRule: UpdatedTamperRulePayload!
	updatedTamperRuleCollection: UpdatedTamperRuleCollectionPayload!
	updatedUpstreamProxyHttp: UpdatedUpstreamProxyHttpPayload!
	updatedUpstreamProxySocks: UpdatedUpstreamProxySocksPayload!
	updatedViewerAssistantUsage: UpdatedViewerAssistantUsagePayload!
	updatedViewerSettings: UpdatedViewerSettingsPayload!
	updatedWorkflow: UpdatedWorkflowPayload!
	uploadedHostedFile: UploadedHostedFilePayload!
}

type TamperRule {
	collection: TamperRuleCollection!
	condition: HTTPQL
	id: ID!
	isEnabled: Boolean!
	isRegex: Boolean!
	matchTerm: String!
	name: String!
	rank: Rank!
	replaceTerm: String!
	strategy: TamperStrategy!
}

type TamperRuleCollection {
	id: ID!
	name: String!
	rules: [TamperRule!]!
}

type TamperRuleCollectionConnection {
	count: Count!
	"""
	A list of edges.
	"""
	edges: [TamperRuleCollectionEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [TamperRuleCollection!]!
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	snapshot: Snapshot!
}

"""
An edge in a connection.
"""
type TamperRuleCollectionEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: TamperRuleCollection!
}

"""
An edge in a connection.
"""
type TamperRuleEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: TamperRule!
}

enum TamperStrategy {
	REQUEST_BODY
	REQUEST_FIRST_LINE
	REQUEST_HEADER
	RESPONSE_BODY
	RESPONSE_FIRST_LINE
	RESPONSE_HEADER
}

interface Task {
	createdAt: DateTime!
	id: ID!
}

type TaskInProgressUserError implements UserError {
	code: String!
	taskId: ID!
}

union TestTamperRuleError = InvalidRegexUserError | OtherUserError

input TestTamperRuleInput {
	isRegex: Boolean!
	matchTerm: String!
	raw: Blob!
	replaceTerm: String!
	strategy: TamperStrategy!
}

type TestTamperRulePayload {
	error: TestTamperRuleError
	raw: Blob
}

input TestUpstreamProxyHttpInput {
	auth: UpstreamProxyAuthInput
	connection: ConnectionInfoInput!
}

type TestUpstreamProxyHttpPayload {
	success: Boolean
}

input TestUpstreamProxySocksInput {
	auth: UpstreamProxyAuthInput
	connection: ConnectionInfoInput!
	includeDns: Boolean!
}

type TestUpstreamProxySocksPayload {
	success: Boolean
}

scalar Timestamp

union TogglePluginError = UnknownIdUserError | PluginUserError | OtherUserError

type TogglePluginPayload {
	error: TogglePluginError
	plugin: Plugin
}

type ToggleUpstreamProxyHttpPayload {
	proxy: UpstreamProxyHttp
}

type ToggleUpstreamProxySocksPayload {
	proxy: UpstreamProxySocks
}

union ToggleWorkflowError = UnknownIdUserError | OtherUserError

type ToggleWorkflowPayload {
	error: ToggleWorkflowError
	workflow: Workflow
}

scalar Token

union UninstallPluginPackageError = UnknownIdUserError | OtherUserError

type UninstallPluginPackagePayload {
	deletedId: ID
	error: UninstallPluginPackageError
}

type UnknownIdUserError implements UserError {
	code: String!
	id: ID!
}

type UnsupportedPlatformUserError implements UserError {
	code: String!
}

union UpdateAutomateSessionError = PermissionDeniedUserError | OtherUserError

input UpdateAutomateSessionInput {
	connection: ConnectionInfoInput!
	raw: Blob!
	settings: AutomateSettingsInput!
}

type UpdateAutomateSessionPayload {
	error: UpdateAutomateSessionError
	session: AutomateSession
}

union UpdateBrowserError = RenderFailedUserError | UnsupportedPlatformUserError | OtherUserError

type UpdateBrowserPayload {
	browser: Browser
	error: UpdateBrowserError
}

union UpdateFilterPresetError = NameTakenUserError | AliasTakenUserError | OtherUserError

input UpdateFilterPresetInput {
	alias: Alias!
	clause: HTTPQL!
	name: String!
}

type UpdateFilterPresetPayload {
	error: UpdateFilterPresetError
	filter: FilterPreset
}

input UpdateRequestMetadataInput {
	color: String
}

type UpdateRequestMetadataPayload {
	metadata: RequestMetadata
	snapshot: Snapshot
}

union UpdateScopeError = InvalidGlobTermsUserError | OtherUserError

input UpdateScopeInput {
	allowlist: [String!]!
	denylist: [String!]!
	name: String!
}

type UpdateScopePayload {
	error: UpdateScopeError
	scope: Scope
}

union UpdateTamperRuleError = UnknownIdUserError | InvalidRegexUserError | InvalidHTTPQLUserError | OtherUserError

input UpdateTamperRuleInput {
	condition: HTTPQL
	isEnabled: Boolean!
	isRegex: Boolean!
	matchTerm: String!
	name: String!
	replaceTerm: String!
	strategy: TamperStrategy!
}

type UpdateTamperRulePayload {
	error: UpdateTamperRuleError
	rule: TamperRule
}

input UpdateUpstreamProxyHttpInput {
	allowlist: [String!]!
	auth: UpstreamProxyAuthInput
	connection: ConnectionInfoInput!
	denylist: [String!]!
	enabled: Boolean!
}

type UpdateUpstreamProxyHttpPayload {
	proxy: UpstreamProxyHttp
}

input UpdateUpstreamProxySocksInput {
	allowlist: [String!]!
	auth: UpstreamProxyAuthInput
	connection: ConnectionInfoInput!
	denylist: [String!]!
	enabled: Boolean!
	includeDns: Boolean!
}

type UpdateUpstreamProxySocksPayload {
	proxy: UpstreamProxySocks
}

input UpdateViewerSettingsInput {
	data: JSON!
	migrations: JSON!
}

type UpdateViewerSettingsPayload {
	settings: UserSettings
}

union UpdateWorkflowError = UnknownIdUserError | ReadOnlyUserError | WorkflowUserError | OtherUserError

input UpdateWorkflowInput {
	definition: JsonObject!
}

type UpdateWorkflowPayload {
	error: UpdateWorkflowError
	workflow: Workflow
}

type UpdatedAssistantMessageTaskPayload {
	task: AssistantMessageTask!
}

type UpdatedAssistantSessionPayload {
	sessionEdge: AssistantSessionEdge!
	snapshot: Snapshot!
}

type UpdatedAutomateEntryPayload {
	automateEntryEdge: AutomateEntryEdge!
	snapshot: Snapshot!
}

type UpdatedAutomateSessionPayload {
	automateSessionEdge: AutomateSessionEdge!
	snapshot: Snapshot!
}

type UpdatedAutomateTaskPayload {
	automateTaskEdge: AutomateTaskEdge!
	snapshot: Snapshot!
}

type UpdatedBackupPayload {
	backup: Backup!
}

type UpdatedBrowserPayload {
	browser: Browser!
}

type UpdatedDataExportPayload {
	dataExportEdge: DataExportEdge!
	snapshot: Snapshot!
}

type UpdatedDeleteInterceptEntriesTaskPayload {
	snapshot: Snapshot!
	task: DeleteInterceptEntriesTask!
}

type UpdatedFilterPresetPayload {
	filterEdge: FilterPresetEdge!
}

type UpdatedHostedFilePayload {
	hostedFile: HostedFile!
}

type UpdatedInterceptEntryPayload {
	interceptEntryEdge(order: InterceptEntryOrderInput): InterceptEntryEdge!
	snapshot: Snapshot!
}

type UpdatedInterceptOptionsPayload {
	options: InterceptOptions!
}

type UpdatedInterceptStatusPayload {
	status: InterceptStatus!
}

type UpdatedPluginPackagePayload {
	package: PluginPackage!
}

type UpdatedPluginPayload {
	plugin: Plugin!
}

type UpdatedProjectPayload {
	project: Project!
}

type UpdatedReplaySessionCollectionPayload {
	collectionEdge: ReplaySessionCollectionEdge!
	snapshot: Snapshot!
}

type UpdatedReplaySessionPayload {
	sessionEdge: ReplaySessionEdge!
	snapshot: Snapshot!
}

type UpdatedRequestMetadataPayload {
	metadata: RequestMetadata!
	snapshot: Snapshot!
}

type UpdatedRequestPayload {
	requestEdge(order: RequestResponseOrderInput): RequestEdge!
	snapshot: Snapshot!
}

type UpdatedScopePayload {
	scopeEdge: ScopeEdge!
	snapshot: Snapshot!
}

type UpdatedSitemapEntryPayload {
	ancestorIds: [ID!]!
	oldRequest: Request
	requestEdge(order: RequestResponseOrderInput): RequestEdge!
	sitemapEntryEdge: SitemapEntryEdge!
	snapshot: Snapshot!
}

type UpdatedTamperRuleCollectionPayload {
	collectionEdge: TamperRuleCollectionEdge!
	snapshot: Snapshot!
}

type UpdatedTamperRulePayload {
	ruleEdge: TamperRuleEdge!
	snapshot: Snapshot!
}

type UpdatedUpstreamProxyHttpPayload {
	proxy: UpstreamProxyHttp!
}

type UpdatedUpstreamProxySocksPayload {
	proxy: UpstreamProxySocks!
}

type UpdatedViewerAssistantUsagePayload {
	usage: AssistantUsage!
}

type UpdatedViewerSettingsPayload {
	settings: UserSettings!
}

type UpdatedWorkflowPayload {
	workflowEdge: WorkflowEdge!
}

scalar Upload

input UploadHostedFileInput {
	file: Upload!
	name: String!
}

type UploadHostedFilePayload {
	hostedFile: HostedFile
}

type UploadedBrowserPayload {
	browser: Browser!
}

type UploadedHostedFilePayload {
	hostedFile: HostedFile!
}

union UpstreamProxyAuth = UpstreamProxyAuthBasic

type UpstreamProxyAuthBasic {
	password: Sensitive!
	username: String!
}

input UpstreamProxyAuthBasicInput {
	password: Sensitive!
	username: String!
}

input UpstreamProxyAuthInput @oneOf {
	basic: UpstreamProxyAuthBasicInput
}

type UpstreamProxyHttp {
	allowlist: [String!]!
	auth: UpstreamProxyAuth
	connection: ConnectionInfo!
	denylist: [String!]!
	enabled: Boolean!
	id: ID!
	rank: Rank!
}

type UpstreamProxySocks {
	allowlist: [String!]!
	auth: UpstreamProxyAuth
	connection: ConnectionInfo!
	denylist: [String!]!
	enabled: Boolean!
	id: ID!
	includeDns: Boolean!
	rank: Rank!
}

scalar Uri

"""
URL is a String implementing the [URL Standard](http://url.spec.whatwg.org/)
"""
scalar Url

type User {
	assistantUsage: AssistantUsage!
	id: ID!
	plugins: [PluginFrontend!]!
	profile: UserProfile!
	settings: UserSettings
}

type UserEntitlement {
	name: String!
}

interface UserError {
	code: String!
}

type UserIdentity {
	email: String!
	name: String!
}

type UserProfile {
	identity: UserIdentity!
	subscription: UserSubscription!
}

type UserSettings {
	data: JSON!
	migrations: JSON!
}

type UserSubscription {
	entitlements: [UserEntitlement!]!
	plan: UserSubscriptionPlan!
}

type UserSubscriptionPlan {
	name: String!
}

scalar Version

type Workflow {
	createdAt: DateTime!
	definition: JsonObject!
	enabled: Boolean!
	global: Boolean!
	id: ID!
	kind: WorkflowKind!
	name: String!
	readOnly: Boolean!
	updatedAt: DateTime!
}

"""
An edge in a connection.
"""
type WorkflowEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: Workflow!
}

enum WorkflowErrorReason {
	EXECUTION_ERROR
	INVALID_INPUT
	INVALID_PROPERTY
	INVALID_WORKFLOW
}

enum WorkflowKind {
	ACTIVE
	CONVERT
	PASSIVE
}

type WorkflowNodeDefinition {
	raw: JsonObject!
}

type WorkflowTask implements Task {
	createdAt: DateTime!
	id: ID!
	workflow: Workflow!
}

type WorkflowUserError implements UserError {
	code: String!
	message: String!
	node: String
	reason: WorkflowErrorReason!
}

schema {
	query: QueryRoot
	mutation: MutationRoot
	subscription: SubscriptionRoot
}
